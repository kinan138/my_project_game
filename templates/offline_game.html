<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Space Typing — Offline</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --cyan:#64ffda; --cyan-20: rgba(100,255,218,.2); --cyan-35: rgba(100,255,218,.35);
    --glow:#16ffd9; --ink:#e6f1ff; --panel:#121a33; --bg:#0b1020;
    --warn:#ff5252; --warn-20:rgba(255,82,82,.2)
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial}
  #stage{width:1200px;height:800px;margin:60px auto 24px;position:relative;overflow:hidden;
         border-radius:16px;background:radial-gradient(1200px 800px at 40% 40%,#151b32,#0d1124);
         box-shadow:0 20px 60px rgba(0,0,0,.35);border:1px solid var(--cyan-20)}
  #hud{position:fixed;left:20px;top:20px;background:var(--panel);border:1px solid var(--cyan-35);
       border-radius:12px;padding:12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.3);min-width:220px;z-index:1000}
  #hud .row{display:flex;justify-content:space-between;margin:.25rem 0;gap:16px}
  #triePanel{position:fixed;right:20px;top:20px;background:var(--panel);border:1px solid var(--cyan-35);
             border-radius:12px;padding:12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.3);width:320px;z-index:1000}
  #triePanel h3{margin:0 0 8px 0;color:#138e7b}
  #trieList{max-height:260px;overflow:auto;font-variant:small-caps}
  #trieList .item{display:flex;justify-content:space-between;padding:2px 6px;border-radius:6px}
  #trieList .hot{background:rgba(255,82,82,.15)}
  .word{position:absolute;padding:8px 12px;border-radius:12px;font-weight:700;letter-spacing:.5px;
        background:#0d2236;border:2px solid var(--cyan);color:var(--ink);z-index:10}
  .word.locked{box-shadow:0 0 14px var(--cyan)}
  .typed{color:var(--cyan);opacity:.85}
  .rem{color:var(--ink)}
  #ship{position:absolute;left:50%;bottom:28px;width:0;height:0;transform:translateX(-50%);
        filter:drop-shadow(0 0 12px var(--cyan));z-index:20}
  #ship::before{content:"";position:absolute;left:-18px;top:-40px;border-left:18px solid transparent;
                border-right:18px solid transparent;border-top:40px solid var(--cyan)}
  #ship::after{content:"";position:absolute;left:-8px;top:-14px;width:16px;height:16px;border-radius:50%;
               box-shadow:0 0 6px var(--glow) inset,0 0 6px var(--glow);background:#002c2a}
  .laser{position:absolute;width:3px;background:var(--cyan);box-shadow:0 0 12px var(--glow);
         transform-origin:bottom center;pointer-events:none;z-index:15}
  .boom{position:absolute;width:12px;height:12px;border-radius:50%;
        box-shadow:0 0 0 0 rgba(255,255,255,.8);animation:boom .45s ease-out forwards;z-index:15}
  @keyframes boom{50%{box-shadow:0 0 18px 12px rgba(255,255,255,.8)}100%{box-shadow:0 0 2px 0 rgba(255,255,255,0);opacity:0}}
  #urgent{position:absolute;left:50%;bottom:120px;transform:translateX(-50%);padding:14px 22px;
          background:var(--warn);color:#fff;border-radius:16px;font-weight:800;letter-spacing:1px;
          box-shadow:0 10px 30px var(--warn-20);display:none;z-index:25}
  #pause{position:absolute;inset:0;background:rgba(0,0,0,.6);display:none;z-index:2000}
  #pause .title{position:absolute;top:130px;left:50%;transform:translateX(-50%);
                font-size:86px;color:#ffdf66;text-shadow:0 0 18px #ffb300}
  #pause .box{position:absolute;top:260px;left:50%;transform:translateX(-50%);
              width:540px;background:#0f1a33;border:3px solid var(--cyan);border-radius:20px;
              box-shadow:0 20px 60px rgba(0,0,0,.5);padding:28px}
  .menuItem{margin:14px 0;padding:16px 18px;border-radius:14px;background:#1e2a4d;border:2px solid var(--cyan);font-size:28px}
  .menuItem.sel{background:#263a6e;box-shadow:0 0 0 3px var(--cyan-20) inset}
  #footer{display:flex;justify-content:center;margin-bottom:30px}
</style>
</head>
<body>
  <!-- HUD -->
  <div id="hud">
    <div class="row"><span>Mode:</span><b>Offline</b></div>
    <div class="row"><span>Score:</span><b id="sc">0</b></div>
    <div class="row"><span>Lives:</span><b id="lv">3</b></div>
    <div class="row"><span>Level:</span><b id="lvn">1 (easy)</b></div>
    <div class="row"><span>Words:</span><b id="wd">0</b></div>
    <div class="row"><span>WPM:</span><b id="wpm">0.0</b></div>
    <div class="row"><span>Accuracy:</span><b id="acc">0%</b></div>
  </div>

  <!-- Trie -->
  <div id="triePanel">
    <h3>Trie Statistics</h3>
    <div id="trieList"></div>
  </div>

  <!-- Stage -->
  <div id="stage" tabindex="0" aria-label="game area">
    <div id="urgent">⚠ URGENT</div>
    <div id="ship"></div>

    <!-- Pause -->
    <div id="pause">
      <div class="title">⏸ PAUSED</div>
      <div class="box">
        <div class="menuItem sel" data-i="0">Resume</div>
        <div class="menuItem" data-i="1">Quit (Return to home)</div>
        <div style="margin-top:8px;color:var(--cyan)">Use ↑/↓ and Enter • Esc to resume</div>
      </div>
    </div>

  </div>

  <div id="footer"><a href="/">⬅ Back to Menu</a></div>

<script>
/* ===== Difficulty profiles (קרוב ל־game.py) ===== */
const DIFFICULTY = {
  easy:   { word_speed: 70,  spawn_every:[1.0, 1.7] },  // px/sec, טווח ספאון שניות
  medium: { word_speed: 95,  spawn_every:[0.8, 1.3] },
  hard:   { word_speed: 120, spawn_every:[0.6, 1.0] },
};
const LEVEL_THRESHOLDS = {2:300, 3:800}; // score→level

/* ===== Constants ===== */
const CANVAS_W = 1200, CANVAS_H = 800;
const DANGER_Y = CANVAS_H - 140;
const PLAYER_LIVES = 3;
const SCORE_PER_CHAR = 5, WORD_BONUS = 10, STREAK_BONUS = 4;

/* ===== Sounds ===== */
let laserSnd=null, boomSnd=null;
try{
  laserSnd = new Audio("/sounds/InGame/laser_shot.wav");
  boomSnd  = new Audio("/sounds/InGame/boom.wav");
  laserSnd.volume=.35; boomSnd.volume=.45;
}catch{}

/* ===== State ===== */
const state = {
  words:[], score:0, lives:PLAYER_LIVES, level:1, wordsDone:0,
  streak:0, currentId:null, paused:false, over:false,
  correct:0, keystrokes:0, t0:performance.now(),
  menuSel:0,
  diffKey:'easy',
  wordSpeed: DIFFICULTY.easy.word_speed,
  spawnEvery: [...DIFFICULTY.easy.spawn_every],
  nextSpawnAt: performance.now() + randRange(...DIFFICULTY.easy.spawn_every)*1000,
  usedWords: new Set(), // מילים שכבר הופיעו במשחק
  completedWords: new Set(), // מילים שהושלמו
  currentTypedPrefix: "", // כמו ב-game.py
};
const stage = document.getElementById('stage');
const pauseEl = document.getElementById('pause');

/* ===== Mini “Trie” stats by first letter (תצוגה) ===== */
class LetterStats{
  constructor(){this.m=new Map();}
  add(w){const k=w[0].toUpperCase();this.m.set(k,(this.m.get(k)||0)+1);}
  remove(w){const k=w[0].toUpperCase();const v=(this.m.get(k)||0)-1;if(v<=0)this.m.delete(k);else this.m.set(k,v);}
  arr(){return Array.from(this.m.entries()).sort((a,b)=>a[0].localeCompare(b[0]));}
}
const letterStats = new LetterStats();

/* ===== Word bank ===== */
let WORDS = []; // יטען מ-wordcache_en.json

// טעינת מילים מ-wordcache_en.json
async function loadWords() {
  try {
    const response = await fetch('/assets/wordcache_en.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // טיפול בפורמט buckets של wordcache_en.json
    if (data.buckets) {
      WORDS = [];
      for (const bucketWords of Object.values(data.buckets)) {
        if (Array.isArray(bucketWords)) {
          WORDS.push(...bucketWords);
        }
      }
    } else if (data.words) {
      WORDS = data.words;
    } else if (Array.isArray(data)) {
      WORDS = data;
    }
    
    // ניקוי מילים - רק אותיות, לפחות 3 תווים
    const seen = new Set();
    const clean = [];
    for (const w of WORDS) {
      if (!w || typeof w !== 'string') continue;
      const word = w.toLowerCase().trim();
      if (word.length < 3 || !word.match(/^[a-z]+$/)) continue;
      if (seen.has(word)) continue;
      seen.add(word);
      clean.push(word);
    }
    
    WORDS = clean;
    console.log(`Loaded ${WORDS.length} words from wordcache_en.json`);
    
    if (WORDS.length === 0) {
      // fallback למילים בסיסיות אם הטעינה נכשלה
      WORDS = ["space","typing","galaxy","planet","rocket","comet","meteor","python","socket","vector","engine",
               "orbit","cosmos","nebula","signal","laser","wide","skip","same","held","hear","heat","fuel",
               "ways","rule","some","lead","big"];
      console.log("Using fallback words");
    }
  } catch (error) {
    console.error("Error loading words:", error);
    // fallback למילים בסיסיות אם הטעינה נכשלה
    WORDS = ["space","typing","galaxy","planet","rocket","comet","meteor","python","socket","vector","engine",
             "orbit","cosmos","nebula","signal","laser","wide","skip","same","held","hear","heat","fuel",
             "ways","rule","some","lead","big"];
    console.log("Using fallback words due to error");
  }
}

/* ===== Helpers ===== */
function uid(){return 'w_'+Date.now()+'_'+((Math.random()*1e5)|0);}//יוצר מזהה ייחודי לכל מילה
function randRange(a,b){return a + Math.random()*(b-a);}

/* ===== Spawning (חלק, לפי טווח) ===== */
function scheduleNextSpawn(){
  const ms = randRange(state.spawnEvery[0], state.spawnEvery[1]) * 1000;
  state.nextSpawnAt = performance.now() + ms;
}
function spawnWord(){
  // בדוק שהמילים נטענו
  if (WORDS.length === 0) {
    console.warn("Words not loaded yet, skipping spawn");
    return;
  }
  
  // מצא מילה שלא הופיעה כבר
  let text = null;
  const exclude = new Set([...state.usedWords, ...state.completedWords]);
  
  // נסה למצוא מילה חדשה עד 50 פעמים
  for(let i = 0; i < 50; i++) {
    const candidate = WORDS[(Math.random()*WORDS.length)|0];
    if (!exclude.has(candidate)) {
      text = candidate;
      break;
    }
  }
  
  // אם לא מצאנו מילה חדשה, השתמש בכל מילה
  if (!text) {
    text = WORDS[(Math.random()*WORDS.length)|0];
  }
  
  const w = {
    id:uid(), text,
    x:40 + Math.random()*(CANVAS_W-160),
    y:-40,
    // מהירות בסיס לפי difficulty עם רנדום קטן
    speed: state.wordSpeed * randRange(0.85,1.15), // px/sec
    typed:"", remaining:text, status:"falling", el:null
  };
  state.words.push(w); 
  state.usedWords.add(text); // הוסף למילים שכבר הופיעו
  letterStats.add(text);
}

/* ===== Drawing & Effects ===== */
function drawWord(w){
  if(!w.el){
    w.el = document.createElement('div');
    w.el.className='word';
    w.el.dataset.id = w.id;
    w.el.innerHTML = `<span class="typed"></span><span class="rem"></span>`;
    stage.appendChild(w.el);
  }
  w.el.style.left = (w.x|0)+"px";
  w.el.style.top = (w.y|0)+"px";
  w.el.querySelector('.typed').textContent = w.typed;
  w.el.querySelector('.rem').textContent   = w.remaining;
  w.el.classList.toggle('locked', state.currentId===w.id);
}
function removeWord(w){ if(w.el?.parentNode) w.el.parentNode.removeChild(w.el); letterStats.remove(w.text); }
function fireLaserTo(x,y){
  const shipRect = document.getElementById('ship').getBoundingClientRect();
  const stageRect= stage.getBoundingClientRect();
  const sx = shipRect.left + shipRect.width/2 - stageRect.left;
  const sy = shipRect.top  - stageRect.top - 10;
  const dx = x - sx, dy = y - sy;
  const len = Math.hypot(dx,dy);
  const ang = Math.atan2(dy,dx) + Math.PI/2;
  const l = document.createElement('div');
  l.className='laser'; l.style.left=(sx-1)+"px"; l.style.bottom=(CANVAS_H - sy)+"px";
  l.style.height="0px"; l.style.transform=`rotate(${ang}rad)`; stage.appendChild(l);
  requestAnimationFrame(()=>{ l.style.transition="height .07s linear"; l.style.height=len+"px";
                              setTimeout(()=>l.remove(),110); });
  if(laserSnd){ try{ laserSnd.currentTime=0; laserSnd.play(); }catch{} }
}
function boom(x,y){
  const b=document.createElement('div'); b.className='boom'; b.style.left=(x-6)+"px"; b.style.top=(y-6)+"px";
  stage.appendChild(b); setTimeout(()=>b.remove(),450);
  if(boomSnd){ try{ boomSnd.currentTime=0; boomSnd.play(); }catch{} }
}

/* ===== UI updates ===== */
const sc = document.getElementById('sc'), lv = document.getElementById('lv'), lvn = document.getElementById('lvn');
const wd = document.getElementById('wd'), wpm = document.getElementById('wpm'), acc = document.getElementById('acc');
function updateHUD(){
  sc.textContent = state.score; lv.textContent = state.lives; wd.textContent = state.wordsDone;
  const label = state.level===1?'easy':state.level===2?'medium':'hard';
  lvn.textContent = `${state.level} (${label})`;
  
  // חשב WPM - אם המשחק נגמר, השתמש בזמן הסיום
  if(!state.over) {
    const mins = Math.max(1e-9,(performance.now()-state.t0)/60000);
    wpm.textContent = ((state.correct/5)/mins).toFixed(1);
  } else if(state.gameEndTime) {
    // המשחק נגמר - השתמש בזמן הסיום שנשמר
    const mins = Math.max(1e-9,(state.gameEndTime-state.t0)/60000);
    wpm.textContent = ((state.correct/5)/mins).toFixed(1);
  }
  
  acc.textContent = Math.round((state.correct/Math.max(1,state.keystrokes))*100)+"%";
}
function updateTriePanel(){
  const box=document.getElementById('trieList'); box.innerHTML="";
  for(const [k,c] of letterStats.arr()){
    const d=document.createElement('div'); d.className="item"+(c>=3?" hot":"");
    d.innerHTML=`<span>${k}:</span><span>${c}</span>`; box.appendChild(d);
  }
}
function urgentBanner(){
  let worst=null; for(const w of state.words){ if(w.status!=="falling") continue; if(!worst||w.y>worst.y) worst=w; }
  const el=document.getElementById('urgent');
  if(worst && worst.y > DANGER_Y-100){ el.style.display="block"; el.textContent="⚠ URGENT: "+worst.text.toUpperCase(); }
  else el.style.display="none";
}

/* ===== Level up ===== */
function maybeLevelUp(){
  if(state.level===1 && state.score>=LEVEL_THRESHOLDS[2]) setDifficulty('medium',2);
  else if(state.level===2 && state.score>=LEVEL_THRESHOLDS[3]) setDifficulty('hard',3);
}
function setDifficulty(key,level=null){
  state.diffKey = key; if(level) state.level = level;
  state.wordSpeed = DIFFICULTY[key].word_speed;
  state.spawnEvery = [...DIFFICULTY[key].spawn_every];
  scheduleNextSpawn();
}

/* ===== Loop (עם dt) ===== */
let lastTime = performance.now();
function tick(now=performance.now()){
  const dt = (now - lastTime)/1000; lastTime = now;

  if(!state.paused && !state.over){
    // spawn
    if(now >= state.nextSpawnAt){ spawnWord(); scheduleNextSpawn(); }
    // move with real px/sec
    for(const w of state.words){
      if(w.status==="completed"||w.status==="missed") continue;
      w.y += w.speed * dt;
      if (w.y >= CANVAS_H - 100){
        w.status="missed"; state.lives=Math.max(0,state.lives-1); state.streak=0; w.el?.style.setProperty('opacity','.35');
        state.completedWords.add(w.text); // הוסף למילים שהושלמו (גם אם נפלו)
      }
    }
    if(state.lives<=0){ state.over=true; showPause(true); }
  }

  for(const w of state.words){ if(w.status!=="missed") drawWord(w); }
  updateHUD(); updateTriePanel(); urgentBanner(); maybeLevelUp();
  requestAnimationFrame(tick);
}

/* ===== Typing ===== */
function findBestMatch(typedPrefix) {
  // מצא את כל המילים שמתחילות עם ה-prefix
  const matches = [];
  for(const w of state.words) {
    if(w.status === "falling" && w.text.toLowerCase().startsWith(typedPrefix.toLowerCase())) {
      matches.push(w);
    }
  }
  
  if(matches.length === 0) return null;
  
  // מיין לפי מיקום (מילים נמוכות יותר עדיפות) - כמו ב-game.py
  return matches.sort((a, b) => b.y - a.y)[0];
}

function findTarget(ch){
  // בנה את ה-prefix החדש
  const testPrefix = state.currentTypedPrefix + ch;
  
  // מצא את המילה הטובה ביותר עם ה-prefix הזה
  const best = findBestMatch(testPrefix);
  
  if(best) {
    // אם יש מילה נוכחית והיא לא המילה הטובה ביותר, אפס אותה
    if(state.currentId && state.currentId !== best.id) {
      const currentWord = state.words.find(w => w.id === state.currentId);
      if(currentWord) {
        currentWord.typed = "";
        currentWord.remaining = currentWord.text;
      }
    }
    
    // עדכן את המילה הנוכחית
    state.currentId = best.id;
    state.currentTypedPrefix = testPrefix;
    best.typed = testPrefix;
    best.remaining = best.text.slice(testPrefix.length);
    
    return best;
  }
  
  return null;
}
stage.addEventListener('keydown',(e)=>{
  if(e.key==="Escape"){ if(!state.over) togglePause(); return; }
  if(state.paused || state.over){ // ניווט pause
    if(["ArrowUp","ArrowDown","Enter","Return"].includes(e.key)){ handlePauseKeys(e.key); }
    return;
  }
  const k=(e.key||"").toLowerCase(); if(k.length!==1 || k<'a'||k>'z') return;
  state.keystrokes++;
  
  const w = findTarget(k);
  if(!w) { 
    state.streak = 0; 
    return; 
  }
  
  // אם מצאנו מילה, עדכן את הסטטיסטיקות
  fireLaserTo(w.x + (w.el?w.el.offsetWidth/2:40), w.y);
  state.score += SCORE_PER_CHAR; 
  state.streak++; 
  state.correct++;
  
  // בדוק אם המילה הושלמה
  if(!w.remaining){
    w.status="completed"; 
    state.wordsDone++;
    state.score += WORD_BONUS + Math.floor(state.streak/Math.max(1,w.text.length))*STREAK_BONUS;
    const bx=w.x+(w.el?w.el.offsetWidth/2:40), by=w.y+(w.el?w.el.offsetHeight/2:20);
    boom(bx,by); 
    w.el?.remove(); 
    letterStats.remove(w.text);
    state.completedWords.add(w.text);
    state.words = state.words.filter(z=>z.id!==w.id); 
    state.currentId = null;
    state.currentTypedPrefix = ""; // אפס את ה-prefix כשמסיימים מילה
  }
});

// תמיכה ב-Backspace כמו ב-game.py
stage.addEventListener('keydown', (e) => {
  if(e.key === "Backspace" && state.currentTypedPrefix && !state.paused && !state.over) {
    state.currentTypedPrefix = state.currentTypedPrefix.slice(0, -1);
    if(state.currentId) {
      const currentWord = state.words.find(w => w.id === state.currentId);
      if(currentWord) {
        currentWord.typed = state.currentTypedPrefix;
        currentWord.remaining = currentWord.text.slice(state.currentTypedPrefix.length);
      }
    }
  }
});

/* ===== Pause ===== */
function togglePause(){ state.paused=!state.paused; pauseEl.style.display = state.paused?"block":"none"; updatePauseSel(); }
function showPause(gameover=false){
  state.paused=true; pauseEl.style.display="block";
  pauseEl.querySelector(".title").textContent = gameover ? "💀 GAME OVER" : "⏸ PAUSED";
  state.menuSel = gameover ? 1 : 0; updatePauseSel();
  
  // אם המשחק נגמר, שמור את ה-WPM האחרון ועצור את הטיימר
  if(gameover) {
    state.gameEndTime = performance.now(); // שמור את זמן הסיום
    const mins = Math.max(1e-9,(state.gameEndTime-state.t0)/60000);
    const finalWPM = ((state.correct/5)/mins).toFixed(1);
    wpm.textContent = finalWPM;
  }
}
function updatePauseSel(){ document.querySelectorAll('.menuItem').forEach(el=>el.classList.toggle('sel', +el.dataset.i===state.menuSel)); }
function handlePauseKeys(k){
  if(k==="ArrowUp")  { state.menuSel=(state.menuSel+2-1)%2; updatePauseSel(); }
  if(k==="ArrowDown"){ state.menuSel=(state.menuSel+1)%2; updatePauseSel(); }
  if(k==="Enter"){
    if(state.menuSel===0){ state.paused=false; pauseEl.style.display="none"; }
    else if(state.menuSel===1){ window.location="/"; }
  }
}


/* ===== Boot ===== */
async function initializeGame() {
  // טען מילים לפני שמתחיל המשחק
  await loadWords();
  
  setDifficulty('easy',1);
  // אפס את ה-sets כשמתחילים משחק חדש
  state.usedWords.clear();
  state.completedWords.clear();
  state.currentTypedPrefix = ""; // אפס את ה-prefix

  // טען הגדרות שמורות
  loadSavedSettings();

  stage.focus();
  updateHUD(); updateTriePanel();
  scheduleNextSpawn();
  requestAnimationFrame(tick);
}

// התחל את המשחק
initializeGame();

function loadSavedSettings() {
    const saved = localStorage.getItem('gameSettings');
    if (saved) {
        try {
            const settings = JSON.parse(saved);
            if (settings.difficulty && settings.difficulty !== 'custom') {
                setDifficulty(settings.difficulty, settings.difficulty === 'easy' ? 1 : settings.difficulty === 'medium' ? 2 : 3);
            } else if (settings.difficulty === 'custom') {
                // השתמש בהגדרות מותאמות אישית
                state.wordSpeed = settings.wordSpeed || 70;
                state.spawnEvery = [settings.spawnRate || 1.0, (settings.spawnRate || 1.0) + 0.5];
                state.level = 1; // תמיד התחל ברמה 1
                scheduleNextSpawn();
            }
        } catch (e) {
            console.log('Error loading settings:', e);
        }
    }
}
</script>
</body>
</html>
